---
layout: post
title: "[Programming] C++의 키워드 몇가지"
date: 2019-02-18
excerpt: " C++의 키워드 몇가지 소개"
tags: [C++]
comments: false
sitemap :
changefreq : daily
priority : 1.0
---

C++ 을 공부하면서 사용해본 혹은 찾아본 예약어를 몇가지 적어보고자 한다.

## const  / constexpr
객체를 상수화 시킴.

  ○ const
    - 컴파일 타임, 런타임에 초기화 될 수 있음
    - 비 정적 멤버함수에만 쓸수 있다
    =>  이 경우 const 멤버 함수는 비 정적 멤버변수의 값을 변경하지 않는다는 것을 보장한다

  ○ constexpr
    - 정수로 계산될수 있는 부분은 컴파일 시간에 계산되도록 할때 주로 사용
    - 비 정적 멤버함수, 생성자에도 사용 가능. virtual(가삼함수)이 아니여야 한다
    - constexpr로 선언된 함수의 파라미터는 모두 리터럴 타입 이거나 리터럴 타임의 참조 형이여야 한다
    - constexpr로 선언된 함수는 본체가 컴파일러에 노출 되어야 한다(치환 되기 때문)
    => 선언과 동시에 정의가 되어 있어야 한다.

  처음 이 두 키워드를 봤을때는 "도대체 무슨 차이지? 상수화는 똑같잖아." 라는 의문을 가졌다.
  하지만 차이는 있었다. 위 설명을 보면 가장큰 차이는 컴파일 타임에만 사용 가능한지 여부다.
  const 의 경우 컴파일 / 런타임 모두 초기화 가능하다. constexpr는 컴파일때만 가능하다.
  뭐... 사실 별 상관없어 보인다. 본인은 constexpr를 주로 사용한다.

---

## mutable
상수화된 멤버 함수에서 멤버 변수를 변경할 수 있도록 해주는 키워드

  ○ const 함수에서 mutalbe로 선언된 비 정적 멤버변수는 수정 가능하다

보통 상수화된 멤버 함수나 상수객체는 값을 변경하지 않는다. 하지만 특정 값만을 제외하고
싶은 경우가 있는데 이때 해당 변수만 mutable 로 선언한다면 상수화된 멤버함수나 상수객체도
값을 변경하는 현상을 즐길수 있을것이다.

---

## explicit
묵시적인 타입변환을 하지 않고 명시적인 타입 변환을 했을 경우만을 허용한다는 키워드
  ○ 원하지 않는 타입변환이 일어났을 경우에 에러를 발생시키기 때문에 이로 인한
  문제를 사전에 방지 할 수 있다

  ○ 객체 생성 관계를 명확하게 하고자 할때 주로 사용됨

간혹 실수로 잘못된 값을 넣어줬는데 잘되는 경우가 발생한다. "어? 왜 되지?" 같은경우가
생기는데 이는 묵시적인 타입변환이 일어나기 때문이다. 이 키워드는 그런 현상을 줄여준다.

---

## export
template를 선언과 정의를 분리 할수 있도록 도와주는 키워드
  ○ 템플릿의 정의를 외부에 알림
  ○ 템플릿이 인스턴스화 된곳과 정의가 된곳 모두 인스턴스화 과정 처리가 되어야 함=> 정의를 포함한 파일을 수정할 경우, 해당 템플릿을 사용하는 모든 파일을 다시 컴파일 해야 한다
  ○ 분리 모델 : export 키워드를 이용하여 명시적 인스턴스화가 아니더라도 선언과 구현을 서로다른 번역 단위에서 작성할 수 있도록 하자는 것

---

## volatile
해당 키워드가 붙은 변수는 최적화를 진행하지 않는다.
  ○ 레지스터에 volatile 변수의 값이 캐시 되지 않게하여 메모리에서 바로 값을 읽도록 한다. CPU내의 캐시는 활용함
  ○ 외부 요인에 의하여 값이 변경될 가능성이 있는 변수들에 주로 사용됨
  => 멀티 쓰레드 프로그래밍, Memory mapped I/O, 시스템 시간 등

학부의 멀티쓰레드 수업에서 처음 봤던거 같다. 멀티쓰레드 수업을 들으면서 컴파일러가 나를
농락해왔다는 사실을 알게 되었다. 기계는 거짓말 하지 않는다고 누가 그런건지 참...
최적화를 하지 말아야 하는경우(최적화 되지 않는 상황에서 디버깅 해야하는 경우 등) 이 키워드를
써주도록 하자.

---

## register
해당 키워드로 선언된 변수는 메모리에 저장되는 것이 아닌 레지스터에 직접 저장 됨
  ○ 실제로 연산에 사용되는 레지스터에 저장하기에 연산 시간을 줄일 수 있다(메모리에서 읽오오는 시간 절약)
  ○ 해당 변수가 굳이 메모리에 기록될 필요가 없을경우 레지스터에 저장 되도록 권유하는 역할
  ○ 최근 컴파일러들은 레지스터에 저장 될수 있다면 알아서 최적화를 해주기 때문에 무시되거나 잘 사용되지 않는다고 한다

---

## auto
변수 초기화 값에 의거하여 변수의 타입을 추론하는 키워드
  ○ 변수 정의때 명시적인 타입을 정하지 않아도 된다
  ○ 값에 상응하는 타입을 추론시켜주는 키워드
  ○ 컴파일때 타입이 결정됨

정말 많이 썼던거 같다. 간혹 자료형들보다 이 키워드를 먼저 배우는 경우가 있는데, 자료형을
선언하거나 타입을 명시해주는게 익숙하지 않은 경우(처음 공부하는 경우)는 이 키워드를
안쓰는 연습도 해보는게 좋다. 물론 요즘에는 마우스 포인터만 가져가면, 형을 알수 있지만
뭐... 귀찮으니까. 그런데 이 키워드로 코딩시간이 약간이나마 줄었던거 같다.

---

## decltype :  주어진 표현식의 타입을 컴파일러가 직접 추론해서 결정하라고 지시하는 키워드
  ○ 주로 함수의 반환타입 결정에 사용함
  ○ 주어진 표현식의 타입을 알려주는 키워드
  ○ 값으로부터 타입을 추론해 낼 수 있는 키워드

---

## = default
컴파일러가 함수를 자동으로 생성하도록 명시적으로 지정

---

## = delete
컴파일러가 함수를 자동으로 생성하지 못하도록 명시적으로 지정

---

## override
오버라이딩된 멤버함수 뒤에 삽입하여, 해당 함수가 오버라이딩 된 함수라는것을 명시
  ○ 오버라이딩된 멤버 함수가, 원본 함수와 형태가 다를경우 문법오류를 발생시켜 오류를 사전 방지

C#을 하면서는 이 키워드를 필수로 써줘야 했던거 같다.

---

## extern
이 키워드로 선언된 전역변수는 이미 다른 파일에 선언되어있는 변수라는 것을 알려줌

---

## inline
인라인 함수로 만들어주는 키워드
  ○ 인라인 함수는 전처리 과정에서 코드를 직접 삽입하여 줌 (매크로 함수와 비슷)
  ○ 일반 함수처럼 정의 할수 있기 때문에 매크로 함수에 비하여 복잡한 정의와 자료형 검사를 함
  ○ 인라인 함수는 최상단이나 헤더파일에 만드는것이 일반적
  ○ 함수 포인터를 사용하는 경우나, 가상함수, 재귀 함수에는 사용할수 없다

---

생각보다 많이 안써본거 같다.
